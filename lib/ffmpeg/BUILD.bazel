load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_binary", "closure_js_library")
load("@npm//@bazel/typescript:index.bzl", "ts_project")
load("//lib:defs.bzl", "runtime_path")
load("//lib:lib.bzl", "package_lib")
load("//toolchains:utils.bzl", "no_error")
load("//toolchains/make:configure.bzl", "configure_make_lib")
load("//tools:javascript.bzl", "minified_js", "wasm_library")
load("//tools:javascript_target.bzl", "JS_TARGET", "TS_TARGET")
load(":package.bzl", "NAME", "STATIC_LIBS")

package(default_visibility = ["//:__subpackages__"])

package_lib()

BUILD_DEPS_K8 = [
    "//lib/yasm:runtime",
]

CONFIGURE_OPTIONS = [
    "--disable-all",
    "--disable-doc",
]

CONFIGURE_OPTIONS_K8 = CONFIGURE_OPTIONS + [
    # The configure script doesn't seem to pick up $CC,
    # so we pass this explicit --cc flag to set the right compiler.
    "--cc=$${EXT_BUILD_ROOT}/$(CC)",
    "--ar=$${EXT_BUILD_ROOT}/external/llvm/bin/llvm-ar",
    "--nm=$${EXT_BUILD_ROOT}/external/llvm/bin/llvm-nm",
    "--ranlib=$${EXT_BUILD_ROOT}/external/llvm/bin/llvm-ranlib",
]

CONFIGURE_OPTIONS_WASM = CONFIGURE_OPTIONS + [
    # The configure script doesn't seem to pick up $CC,
    # so we pass this explicit --cc flag to set the right compiler.
    "--cc=$(execpath @emscripten_bin_linux//:emscripten/emcc)",
    "--ar=$(execpath @emscripten_bin_linux//:emscripten/emar)",
    "--nm=$(execpath @emscripten_bin_linux//:emscripten/emnm)",
    "--ranlib=$(execpath @emscripten_bin_linux//:emscripten/emranlib)",

    # Some of these are copied from:
    # github.com/ffmpegwasm/ffmpeg.wasm @ build/ffmpeg.sh
    "--arch=x86_32",
    "--target-os=none",
    "--enable-cross-compile",
    "--disable-asm",
    "--disable-stripping",  # Disable stripping as it won't work.
    "--disable-programs",  # Do not build ffmpeg, ffprobe and ffplay.
    "--disable-runtime-cpudetect",  # No CPU detection at runtime.
    "--disable-autodetect",  # Disable env auto detection.
    '--extra-cflags="{}"'.format(no_error([
        "implicit-const-int-float-conversion",
    ])),
]

OPT_ON = ["--enable-lto"]

DBG_OFF = ["--disable-debug"]

configure_make_lib(
    name = NAME,
    build_data = {
        "//config:wasm": [],
        "//conditions:default": BUILD_DEPS_K8,
    },
    configure_options = select({
        "//config:k8_dbg": CONFIGURE_OPTIONS_K8,
        "//config:k8_fastbuild": CONFIGURE_OPTIONS_K8 + DBG_OFF,
        "//config:k8_opt": CONFIGURE_OPTIONS_K8 + DBG_OFF + OPT_ON,
        "//config:wasm_dbg": CONFIGURE_OPTIONS_WASM,
        "//config:wasm_fastbuild": CONFIGURE_OPTIONS_WASM + DBG_OFF,
        "//config:wasm_opt": CONFIGURE_OPTIONS_WASM + DBG_OFF + OPT_ON,
    }),
    env = {
        "//config:wasm": {},
        "//conditions:default": {"PATH": runtime_path(BUILD_DEPS_K8)},
    },
    out_static_libs = STATIC_LIBS,
)

ts_project(
    name = "ffmpeg_ts",
    srcs = [
        # Must be first:
        "types.ts",
    ] + [
        # keep sorted
        "api.ts",
    ],
    tsconfig = {"compilerOptions": {
        "target": TS_TARGET,
        "esModuleInterop": True,
        "module": "commonjs",
    }},
    deps = [
        "@npm//@types/emscripten",
        "@npm//@types/node",
    ],
)

wasm_library(
    name = "ffmpeg_wasm",
    srcs = [":ffmpeg_ts"],
    build_settings = {
        # Single-threaded builds start with less memory, so allow memory to grow.
        "ALLOW_MEMORY_GROWTH": "1",
        # No need for the virtual filesystem support.
        "FILESYSTEM": "0",
    },
    exclude = ["types.ts"],
    exported_functions = [
        # Emscripten:
        "free",
        "malloc",

        # libavutil:
        "av_version_info",
        "avutil_configuration",
        "avutil_license",
        "avutil_version",
    ],
    exported_runtime_methods = [
        "cwrap",
    ],
    deps = [":ffmpeg"],
)

filegroup(
    name = "ffmpeg_js_0",
    srcs = [":ffmpeg_wasm"],
    output_group = "js",
)

filegroup(
    name = "ffmpeg_wasm_0",
    srcs = [":ffmpeg_wasm"],
    output_group = "wasm",
)

# Step to remove the "import.meta.url" global.
# TODO: Use a newer Closure compiler that supports modules.
genrule(
    name = "ffmpeg_js_1",
    srcs = [":ffmpeg_js_0"],
    outs = ["ffmpeg_js_1.js"],
    cmd = r"""
sed --expression '
    s/import\.meta\.url/"import.meta.url"/g
  ' <$< >$@
""",
)

closure_js_library(
    name = "ffmpeg_js_2",
    srcs = [":ffmpeg_js_1"],
    no_closure_library = True,
    suppress = [
        # Closure Compiler currently does not consume TypeScript .d.ts inputs.
        # Therefore it has no clue about the types, so we disable some optimisations.
        "JSC_UNKNOWN_EXPR_TYPE",
        # When building with MODULARIZE=0, the Module object gets redeclared.
        "JSC_REFERENCE_BEFORE_DECLARE",
        # When building with MODULARIZE=0, the Module object gets assigned on the global "this" object.
        "JSC_USED_GLOBAL_THIS",
        # Emscripten's non-optimised code uses assertions.
        "JSC_DETERMINISTIC_TEST",
        # Emscripten's non-optimised code uses a lot of "environment detection" magic.
        "JSC_UNDEFINED_VARIABLE",
        # Emscripten re-declares the Module object, unless EXPORT_NAME is provided.
        "JSC_REDECLARED_VARIABLE",
        # Suppress use of "use_strict";
        "JSC_USELESS_CODE",
        # These are required for double-optimised code (-c opt, which also enables acorn).
        "JSC_NOT_A_CONSTRUCTOR",
        "JSC_TYPE_MISMATCH",
        "JSC_WRONG_ARGUMENT_COUNT",
    ],
)

closure_js_binary(
    name = "ffmpeg_js_3",
    compilation_level = "SIMPLE",
    dependency_mode = "SORT_ONLY",
    language = JS_TARGET,
    deps = [":ffmpeg_js_2"],
)

genrule(
    name = "ffmpeg_js_4",
    srcs = [":ffmpeg_js_3"],
    outs = ["ffmpeg_js_4.js"],
    cmd = r"""
sed --expression '
    s/\"import\.meta\.url\"/import.meta.url/g
  ' <$(RULEDIR)/ffmpeg_js_3.js >$@
sed --in-place --regexp-extended '
    1h;2,$$H;$$!d;g;
    s/\$$\$$module\$$[^=]+//
    s/[;\n,]*\$$jscompDefaultExport\$$.*/;export default Module;/g
  ' $@
""",
)

minified_js(
    name = "ffmpeg_min_js",
    src = ":ffmpeg_js_4",
)
