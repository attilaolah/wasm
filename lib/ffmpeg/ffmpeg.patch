diff --git Makefile Makefile
index 78652c47bd..ad19eea7d3 100644
--- Makefile
+++ Makefile
@@ -37,7 +37,7 @@ DATA_FILES := $(wildcard $(SRC_PATH)/presets/*.ffpreset) $(SRC_PATH)/doc/ffprobe
 SKIPHEADERS = compat/w32pthreads.h
 
 # first so "all" becomes default target
-all: all-yes
+all: patch all-yes
 
 include $(SRC_PATH)/tools/Makefile
 include $(SRC_PATH)/ffbuild/common.mak
@@ -196,5 +196,11 @@ $(sort $(OUTDIRS)):
 # so this saves some time on slow systems.
 .SUFFIXES:
 
-.PHONY: all all-yes alltools build check config testprogs
-.PHONY: *clean install* uninstall*
+.PHONY: all all-yes alltools build check config testprogs patch
+.PHONY: *cl
+
+patch::
+	sed --in-place --regexp-extended 's/^#define HAVE_SOCKLEN_T 0/#define HAVE_SOCKLEN_T 1/' config.h
+	sed --in-place --regexp-extended 's/^#define HAVE_STRUCT_ADDRINFO 0/#define HAVE_STRUCT_ADDRINFO 1/' config.h
+	sed --in-place --regexp-extended 's/^#define HAVE_STRUCT_SOCKADDR_STORAGE 0/#define HAVE_STRUCT_SOCKADDR_STORAGE 1/' config.h
+	sed --in-place --regexp-extended 's:(--[^=]+=)(/[^/ ]+)*/:\1/redacted/:g' config.h
diff --git fftools/cmdutils.c fftools/cmdutils.c
index 156c13801a..80bb3f2e7a 100644
--- fftools/cmdutils.c
+++ fftools/cmdutils.c
@@ -24,6 +24,9 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <math.h>
+#ifdef FFMPEG_WASM
+#include <emscripten.h>
+#endif
 
 /* Include only the enabled headers since some compilers (namely, Sun
    Studio) will not omit unused inline functions and create undefined
@@ -106,6 +109,28 @@ int parse_number(const char *context, const char *numstr, int type,
     return AVERROR(EINVAL);
 }
 
+#ifdef FFMPEG_WASM
+void exit_program(int ret)
+{
+    /*
+     * abort() is used instead of exit() because exit() not only
+     * terminates ffmpeg but also the whole node.js program, which 
+     * is not ideal.
+     *
+     * abort() terminiates the ffmpeg with an JS exception
+     *
+     *   RuntimeError: Aborted...
+     *
+     * This excpetion is catch and not visible to users.
+     *
+     */
+    EM_ASM({
+        Module.ret = $0;
+    }, ret);
+    abort();
+}
+#endif
+
 void show_help_options(const OptionDef *options, const char *msg, int req_flags,
                        int rej_flags, int alt_flags)
 {
diff --git fftools/ffmpeg.c fftools/ffmpeg.c
index 46a85b41a8..14aaa8878e 100644
--- fftools/ffmpeg.c
+++ fftools/ffmpeg.c
@@ -32,6 +32,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#ifdef FFMPEG_WASM
+#include <emscripten.h>
+#endif
 
 #if HAVE_IO_H
 #include <io.h>
@@ -493,6 +496,12 @@ void close_output_stream(OutputStream *ost)
         sq_send(of->sq_encode, ost->sq_idx_encode, SQFRAME(NULL));
 }
 
+#ifdef FFMPEG_WASM
+EM_JS(void, send_progress, (double progress, double time), {
+    Module.receiveProgress(progress, time);
+});
+#endif
+
 static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)
 {
     AVBPrint buf, buf_script;
@@ -574,6 +583,26 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
     hours = FFABS64U(pts) / AV_TIME_BASE / 3600;
     hours_sign = (pts < 0) ? "-" : "";
 
+#ifdef FFMPEG_WASM
+    /* send_progress here only works when the duration of
+     * input and output file are the same, other cases (ex. trim)
+     * still WIP.
+     *
+     * TODO: support cases like trim.
+     */
+    int64_t duration = -1;
+    int64_t pts_abs = FFABS(pts);
+    /* Use the longest duration among all input files.
+     */
+    for (int i = 0; i < nb_input_files; i++) {
+      int64_t file_duration = input_files[i]->ctx->duration;
+      if (file_duration > duration) {
+        duration = file_duration;
+      }
+    }
+    send_progress((double)pts_abs / (double)duration, (double)pts_abs);
+#endif
+
     bitrate = pts != AV_NOPTS_VALUE && pts && total_size >= 0 ? total_size * 8 / (pts / 1000.0) : -1;
     speed   = pts != AV_NOPTS_VALUE && t != 0.0 ? (double)pts / AV_TIME_BASE / t : -1;
 
@@ -621,7 +650,12 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
     }
 
     if (print_stats || is_last_report) {
+#ifdef FFMPEG_WASM
+        // Always print a new line of message.
+        const char end = '\n'; //is_last_report ? '\n' : '\r';
+#else
         const char end = is_last_report ? '\n' : '\r';
+#endif
         if (print_stats==1 && AV_LOG_INFO > av_log_get_level()) {
             fprintf(stderr, "%s    %c", buf.str, end);
         } else
@@ -646,6 +680,14 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
     }
 
     first_report = 0;
+
+#if FFMPEG_WASM
+    if (is_last_report) {
+      // Make sure the progress is ended with 1.
+      if (pts_abs != duration) send_progress(1, (double)pts_abs);
+      print_final_stats(total_size);
+    }
+#endif
 }
 
 int copy_av_subtitle(AVSubtitle *dst, const AVSubtitle *src)
@@ -1160,6 +1202,18 @@ static int transcode_step(OutputStream *ost)
     return 0;
 }
 
+#ifdef FFMPEG_WASM
+/* is_timeout checks if transcode() is running longer
+ * than a timeout value, return 1 when timeout.
+ */
+EM_JS(int, is_timeout, (int64_t diff), {
+    if (Module.timeout === -1) return 0;
+    else {
+      return Module.timeout <= diff;
+    }
+});
+#endif
+
 /*
  * The following code is the main loop of the file converter
  */
@@ -1184,6 +1238,10 @@ static int transcode(int *err_rate_exceeded)
         OutputStream *ost;
         int64_t cur_time= av_gettime_relative();
 
+#ifdef FFMPEG_WASM
+        if (is_timeout((cur_time - timer_start) / 1000) == 1) exit_program(1);
+#endif
+
         /* if 'q' pressed, exits */
         if (stdin_interaction)
             if (check_keyboard_interaction(cur_time) < 0)
@@ -1289,8 +1347,52 @@ static int64_t getmaxrss(void)
 #endif
 }
 
+#ifdef FFMPEG_WASM
+/* init_globals initializes global variables to enable multiple
+ * calls of ffmpeg().
+ *
+ * This is not required in the original command line version as
+ * the global varialbes are always re-initialized when calling
+ * main() function.
+ */
+void init_globals() {
+  nb_frames_dup = 0;
+  dup_warning = 1000;
+  nb_frames_drop = 0;
+  nb_output_dumped = 0;
+
+  progress_avio = NULL;
+
+  input_files = NULL;
+  nb_input_files = 0;
+
+  output_files = NULL;
+  nb_output_files = 0;
+
+  filtergraphs = NULL;
+  nb_filtergraphs = 0;
+
+  received_sigterm = 0;
+  received_nb_signals = 0;
+  transcode_init_done = ATOMIC_VAR_INIT(0);
+  ffmpeg_exited = 0;
+  copy_ts_first_pts = AV_NOPTS_VALUE;
+}
+
+/* ffmpeg() is simply a rename of main(), but it makes things easier to
+ * control as main() is a special function name that might trigger
+ * some hidden mechanisms.
+ *
+ * One example is that when using multi-threading, a proxy_main() function
+ * might be used instead of main().
+ */
+int ffmpeg(int argc, char **argv)
+{
+    init_globals();
+#else
 int main(int argc, char **argv)
 {
+#endif
     int ret, err_rate_exceeded;
     BenchmarkTimeStamps ti;
 
diff --git fftools/ffplay.c fftools/ffplay.c
index d8c69e10bc..7663bafab0 100644
--- fftools/ffplay.c
+++ fftools/ffplay.c
@@ -3653,7 +3653,11 @@ void show_help_default(const char *opt, const char *arg)
 }
 
 /* Called from the main */
+#ifdef FFMPEG_WASM
+int ffplay(int argc, char **argv)
+#else
 int main(int argc, char **argv)
+#endif
 {
     int flags, ret;
     VideoState *is;
diff --git fftools/ffprobe.c fftools/ffprobe.c
index 71f6cc3a74..2bc991509f 100644
--- fftools/ffprobe.c
+++ fftools/ffprobe.c
@@ -4142,7 +4142,11 @@ static inline int check_section_show_entries(int section_id)
             do_show_##varname = 1;                                      \
     } while (0)
 
+#ifdef FFMPEG_WASM
+int ffprobe(int argc, char **argv)
+#else
 int main(int argc, char **argv)
+#endif
 {
     const Writer *w;
     WriterContext *wctx;
